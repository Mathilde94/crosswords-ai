from __future__ import annotations
from typing import List, Tuple, Dict

from .base import Board


HORIZONTAL_DIRECTION = (0, 1)
VERTICAL_DIRECTION = (1, 0)


class CrosswordBoard(Board):
    def __init__(self, width=20, height=20):
        super().__init__(width, height)
        self.initial_position = (int(height * 0.5), int(width * 0.25))
        self.initial_direction = HORIZONTAL_DIRECTION
        self.words_positions = {}

    def create_boards_with_word(self, word: str) -> List[CrosswordBoard]:
        """Return all boards generated by adding the word to the current board."""
        boards = []
        # Iterate over already placed words: if the word intersects with any of them, try to place it
        words_positions = self.words_positions.copy()
        for w, placement in words_positions.items():
            w_direction = placement[1]
            w_position = placement[0]
            opposite_direction = (w_direction[1], w_direction[0])
            intersections = self._get_letter_intersections(w, word)
            if not intersections:
                continue
            for i, (j, letter) in intersections.items():
                # we need to go the opposite direction from the word w
                new_start = (
                    w_position[0] + i * opposite_direction[1] - j * opposite_direction[0],
                    w_position[1] + i * opposite_direction[0] - j * opposite_direction[1]
                )
                new_board = self.__copy__()
                word_placed = new_board.place_word(word, opposite_direction, new_start)
                if word_placed:
                    new_board.words_positions[word] = (new_start, opposite_direction)
                    boards.append(new_board)
        return boards

    def set_first_word(self, word: str) -> bool:
        result = super().place_word(word, self.initial_direction, self.initial_position)
        if result:
            self.words_positions[word] = (self.initial_position, self.initial_direction)
        return result

    def trim(self):
        min_x, max_x, min_y, max_y = self.get_borders()
        super().trim_to(min_x, max_x, min_y, max_y)
        for word, (position, direction) in self.words_positions.items():
            self.words_positions[word] = ((position[0] - min_x, position[1] - min_y), direction)

    @staticmethod
    def _get_letter_intersections(word1: str, word2: str) -> Dict[int, Tuple[int, str]]:
        """Get the intersections between two words"""
        intersections = {}
        for i, letter1 in enumerate(word1):
            for j, letter2 in enumerate(word2):
                if letter1 == letter2:
                    intersections[i] = (j, letter1)
        return intersections

    def __str__(self):
        output = "Words: {words}.\n".format(words=self.words_positions)
        return output + super().__str__()

    def __copy__(self):
        new_board = CrosswordBoard(self.width, self.height)
        new_board.matrix = [[self.matrix[i][j] for j in range(self.width)] for i in range(self.height)]
        new_board.words_positions = self.words_positions.copy()
        return new_board
