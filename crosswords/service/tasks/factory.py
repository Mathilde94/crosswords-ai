from __future__ import annotations
from typing import Dict, List, Tuple

from crosswords.models.concept import Concept

from crosswords.models.board.crossword_board import CrosswordBoard
from crosswords.models.board.exceptions import TooManyWordsError


def get_letter_intersections(word1: str, word2: str) -> Dict[int, Tuple[int, str]]:
    """Get the intersections between two words"""
    intersections = {}
    for i, letter1 in enumerate(word1):
        for j, letter2 in enumerate(word2):
            if letter1 == letter2:
                intersections[i] = (j, letter1)
    return intersections


class CrosswordFactory:
    TOP_CROSSWORDS = 3
    LIMIT_CONCEPTS_WORDS = 10

    def __init__(self, concepts: List[Concept], width=20, height=20):
        if len(concepts) > self.LIMIT_CONCEPTS_WORDS:
            raise TooManyWordsError("Please provide less than 10 words")
        self.concepts = concepts
        self.width = width
        self.height = height
        self.crosswords = []
        self.best_crosswords = []
        self.best_crossword = None

    async def generate_best_board(self) -> CrosswordBoard:
        initial_crossword = CrosswordBoard(self.width, self.height)
        initial_crossword.set_first_word(self.concepts[0].word)
        self.crosswords.append(initial_crossword)
        for i in range(1, len(self.concepts)):
            nb_boards = len(self.crosswords)
            for index in range(nb_boards):
                self.crosswords += CrosswordFactory.next_boards_with_word(self.crosswords[index], self.concepts[i].word)

        for board in self.crosswords:
            board.trim()

        # now fetch the top 5 boards:
        self.best_crosswords = sorted(
            self.crosswords,
            key=lambda x: (len(x.words_positions), x.density),
            reverse=True
        )[:self.TOP_CROSSWORDS]

        # Set the best board
        self.best_crossword = self.best_crosswords[0]
        return self.best_crossword

    @staticmethod
    def next_boards_with_word(initial_board: CrosswordBoard, word: str) -> List[CrosswordBoard]:
        """Return all boards generated by adding the word to the current board."""
        boards = []
        # Iterate over already placed words: if the word intersects with any of them, try to place it
        words_positions = initial_board.words_positions.copy()
        for w, placement in words_positions.items():
            w_direction = placement[1]
            w_position = placement[0]
            opposite_direction = (w_direction[1], w_direction[0])
            intersections = get_letter_intersections(w, word)
            if not intersections:
                continue
            for i, (j, letter) in intersections.items():
                # we need to go the opposite direction from the word w
                new_start = (
                    w_position[0] + i * opposite_direction[1] - j * opposite_direction[0],
                    w_position[1] + i * opposite_direction[0] - j * opposite_direction[1]
                )
                new_board = initial_board.__copy__()
                word_placed = new_board.place_word(word, opposite_direction, new_start)
                if word_placed:
                    new_board.words_positions[word] = (new_start, opposite_direction)
                    boards.append(new_board)
        return boards

    @staticmethod
    def from_words(words: List[str], width=20, height=20) -> CrosswordFactory:
        concepts = [Concept(word) for word in words]
        return CrosswordFactory(concepts, width, height)
